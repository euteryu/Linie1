import pygame
import json
import sys
import math
from tkinter import filedialog, Tk

# --- Configuration ---
OUTPUT_FILE = 'ui_layout.py' # Now generates a Python file
POLYGON_CLOSE_TOLERANCE = 15

# --- Colors and Fonts ---
COLOR_WHITE = (255, 255, 255)
COLOR_BLACK = (0, 0, 0)
COLOR_RECT_FILL = (255, 165, 0, 150)
COLOR_RECT_BORDER = (255, 255, 0)
COLOR_SELECTED_BORDER = (255, 0, 255, 255)
COLOR_POLYGON_VERTEX = (0, 255, 0)
COLOR_POLYGON_LINE = (0, 200, 0)
COLOR_SNAP_CIRCLE = (0, 255, 255, 100)
FONT_SIZE = 22

class LayoutTool:
    def __init__(self):
        pygame.init()
        self.tk_root = Tk(); self.tk_root.withdraw()
        self.screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
        self.screen_width, self.screen_height = self.screen.get_size()
        pygame.display.set_caption("Linie 1 - UI Layout Code Generator")
        self.font = pygame.font.Font(None, FONT_SIZE)
        self.clock = pygame.time.Clock()
        self.background = pygame.Surface((self.screen_width, self.screen_height)); self.background.fill(COLOR_BLACK)
        
        self.regions = {} # The main data store
        self.selected_name = None
        self.mode = "select"; self.start_pos = None; self.current_polygon_points = []; self.history = []

    def load_mockup(self):
        filepath = filedialog.askopenfilename(title="Select Mockup Image")
        if filepath:
            try:
                self.background = pygame.image.load(filepath).convert()
                self.background = pygame.transform.scale(self.background, (self.screen_width, self.screen_height))
            except Exception as e: print(f"Error loading image: {e}")

    def export_to_python(self):
        """Generates the ui_layout.py file with bounds and precise data."""
        with open(OUTPUT_FILE, 'w') as f:
            f.write("# THIS FILE IS AUTO-GENERATED BY THE LAYOUT TOOL. DO NOT EDIT MANUALLY.\n")
            f.write("import pygame\n\n")

            for name, region in self.regions.items():
                st = region['shape_type']
                sd = region['shape_data']
                
                # Write the bounding box for every shape
                bounds_rect = pygame.Rect(0,0,0,0)
                if st == 'rectangle': bounds_rect = pygame.Rect(sd)
                elif st == 'circle': bounds_rect = pygame.Rect(sd[0]-sd[2], sd[1]-sd[2], sd[2]*2, sd[2]*2)
                elif st == 'polygon':
                    min_x=min(p[0] for p in sd); max_x=max(p[0] for p in sd)
                    min_y=min(p[1] for p in sd); max_y=max(p[1] for p in sd)
                    bounds_rect = pygame.Rect(min_x, min_y, max_x-min_x, max_y-min_y)
                
                f.write(f"{name}_bounds = pygame.Rect({bounds_rect.x}, {bounds_rect.y}, {bounds_rect.width}, {bounds_rect.height})\n")

                # Write the precise data dictionary
                data_str = f"'shape': '{st}'"
                if st == 'circle': data_str += f", 'center': ({sd[0]}, {sd[1]}), 'radius': {sd[2]}"
                if st == 'polygon': data_str += f", 'points': {sd}"
                
                f.write(f"{name}_data = {{{data_str}}}\n\n")
        
        print(f"--- Layout code successfully generated in '{OUTPUT_FILE}' ---")

    def add_region(self, name, region_data):
        if name in self.regions: print(f"Warning: Region name '{name}' already exists. Overwriting.")
        self.regions[name] = region_data
        self.history.append(name)
        print(f"Added/Updated region: '{name}'")

    def undo_last_action(self):
        if not self.history: return
        last_name = self.history.pop()
        if last_name in self.regions:
            del self.regions[last_name]; print(f"Undone adding '{last_name}'")

    def handle_simple_input(self, prompt):
        input_text = ""
        while True:
            for event in pygame.event.get():
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_RETURN: return input_text
                    elif event.key == pygame.K_BACKSPACE: input_text = input_text[:-1]
                    else: input_text += event.unicode
            self.draw()
            box_rect = pygame.Rect(self.screen_width//2 - 250, self.screen_height//2 - 50, 500, 100)
            pygame.draw.rect(self.screen, (30,30,70), box_rect); pygame.draw.rect(self.screen, COLOR_WHITE, box_rect, 2)
            self.screen.blit(self.font.render(prompt, True, COLOR_WHITE), (box_rect.x+10, box_rect.y+10))
            self.screen.blit(self.font.render(input_text, True, COLOR_WHITE), (box_rect.x+10, box_rect.y+40))
            pygame.display.flip()

    def finalize_and_add_shape(self, shape_type, shape_data):
        name = self.handle_simple_input(f"Enter unique name for new {shape_type}:")
        if not name: print("Cancelled adding shape: No name provided."); return
        if shape_type == "polygon": shape_data = list(shape_data)
        self.add_region(name, {"shape_type": shape_type, "shape_data": shape_data})

    def draw_region(self, name, region):
        st = region['shape_type']; sd = region['shape_data']
        border_color = COLOR_SELECTED_BORDER if name == self.selected_name else COLOR_RECT_BORDER
        try:
            if not sd: return
            if st == "rectangle":
                rect = pygame.Rect(sd)
                s = pygame.Surface(rect.size, pygame.SRCALPHA); s.fill(COLOR_RECT_FILL); self.screen.blit(s, rect.topleft)
                pygame.draw.rect(self.screen, border_color, rect, 2)
            elif st == "circle":
                center, r = (sd[0], sd[1]), sd[2]
                s = pygame.Surface((r*2, r*2), pygame.SRCALPHA); pygame.draw.circle(s, COLOR_RECT_FILL, (r,r), r); self.screen.blit(s, (center[0]-r, center[1]-r))
                pygame.draw.circle(self.screen, border_color, center, r, 2)
            elif st == "polygon":
                pygame.draw.polygon(self.screen, COLOR_RECT_FILL, sd)
                pygame.draw.polygon(self.screen, border_color, sd, 2)
            
            # Draw name tag
            text_surf = self.font.render(name, True, COLOR_BLACK, COLOR_WHITE)
            text_pos = sd[0] if st == 'polygon' else (sd[0], sd[1])
            self.screen.blit(text_surf, (text_pos[0] + 5, text_pos[1] + 5))

        except (ValueError, IndexError) as e: print(f"Error drawing '{name}': {e}")

    def draw(self):
        self.screen.blit(self.background, (0, 0))
        for name, region in self.regions.items(): self.draw_region(name, region)
        help_text = [f"MODE: {self.mode.upper()} | SELECTED: {self.selected_name}", "[R]ect | [C]ircle | [G]eometry | [ESC] Select Mode", "[M]ockup | [E]xport Code | [Ctrl+Z] Undo"]
        if self.mode == 'draw_polygon': help_text.append("Left-click adds point | Click near start OR Right-click to finish")
        for i, line in enumerate(help_text):
            surf = self.font.render(line, True, COLOR_WHITE)
            bg_rect = surf.get_rect(topleft=(10, 10+i*(FONT_SIZE+4))).inflate(8,8)
            s = pygame.Surface(bg_rect.size, pygame.SRCALPHA); s.fill((0,0,0,180)); self.screen.blit(s, bg_rect.topleft)
            self.screen.blit(surf, (14, 14+i*(FONT_SIZE+4)))

    def run(self):
        while True:
            mouse_pos = pygame.mouse.get_pos()
            for event in pygame.event.get():
                if event.type == pygame.QUIT: pygame.quit(); sys.exit()
                
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE: self.mode = "select"; self.current_polygon_points.clear()
                    elif event.key == pygame.K_r: self.mode = "draw_rectangle"
                    elif event.key == pygame.K_c: self.mode = "draw_circle"
                    elif event.key == pygame.K_g: self.mode = "draw_polygon"; self.current_polygon_points.clear()
                    elif event.key == pygame.K_m: self.load_mockup()
                    elif event.key == pygame.K_e: self.export_to_python()
                    elif event.key == pygame.K_z and (pygame.key.get_mods() & pygame.KMOD_CTRL): self.undo_last_action()
                
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if self.mode == "select" and event.button == 1:
                        # Simple selection without complex hierarchy checks for now
                        self.selected_name = next((name for name, comp in reversed(list(self.regions.items())) if self.is_point_in_component(mouse_pos, comp)), None)
                    elif self.mode in ["draw_rectangle", "draw_circle"]: self.start_pos = mouse_pos
                    elif self.mode == "draw_polygon":
                        close_shape = event.button==1 and len(self.current_polygon_points)>=3 and math.hypot(mouse_pos[0]-self.current_polygon_points[0][0], mouse_pos[1]-self.current_polygon_points[0][1]) < POLYGON_CLOSE_TOLERANCE
                        if close_shape or (event.button==3 and len(self.current_polygon_points)>=3):
                            self.finalize_and_add_shape("polygon", self.current_polygon_points)
                            self.current_polygon_points.clear(); self.mode = "select"
                        elif event.button == 1: self.current_polygon_points.append(mouse_pos)

                if event.type == pygame.MOUSEBUTTONUP and event.button == 1 and self.start_pos:
                    if self.mode == "draw_rectangle":
                        rect_data = [min(self.start_pos[0],mouse_pos[0]), min(self.start_pos[1],mouse_pos[1]), abs(self.start_pos[0]-mouse_pos[0]), abs(self.start_pos[1]-mouse_pos[1])]
                        if rect_data[2]>5 and rect_data[3]>5: self.finalize_and_add_shape("rectangle", rect_data)
                    elif self.mode == "draw_circle":
                        radius = int(math.hypot(mouse_pos[0]-self.start_pos[0], mouse_pos[1]-self.start_pos[1]))
                        if radius > 5: self.finalize_and_add_shape("circle", [self.start_pos[0], self.start_pos[1], radius])
                    self.start_pos = None; self.mode = "select"
            
            self.draw() # Draw main scene
            if self.start_pos: # Draw live previews
                if self.mode=="draw_rectangle": pygame.draw.rect(self.screen, COLOR_RECT_BORDER, (min(self.start_pos[0],mouse_pos[0]), min(self.start_pos[1],mouse_pos[1]), abs(self.start_pos[0]-mouse_pos[0]), abs(self.start_pos[1]-mouse_pos[1])), 2)
                elif self.mode=="draw_circle": pygame.draw.circle(self.screen, COLOR_RECT_BORDER, self.start_pos, int(math.hypot(mouse_pos[0]-self.start_pos[0], mouse_pos[1]-self.start_pos[1])), 2)
            if self.mode == "draw_polygon" and self.current_polygon_points:
                pygame.draw.lines(self.screen, COLOR_POLYGON_LINE, False, self.current_polygon_points + [mouse_pos], 2)
                for p in self.current_polygon_points: pygame.draw.circle(self.screen, COLOR_POLYGON_VERTEX, p, 4)
                if len(self.current_polygon_points) >= 2 and math.hypot(mouse_pos[0]-self.current_polygon_points[0][0], mouse_pos[1]-self.current_polygon_points[0][1]) < POLYGON_CLOSE_TOLERANCE:
                    s = pygame.Surface((POLYGON_CLOSE_TOLERANCE*2, POLYGON_CLOSE_TOLERANCE*2), pygame.SRCALPHA); pygame.draw.circle(s, COLOR_SNAP_CIRCLE, (POLYGON_CLOSE_TOLERANCE, POLYGON_CLOSE_TOLERANCE), POLYGON_CLOSE_TOLERANCE); self.screen.blit(s, (self.current_polygon_points[0][0]-POLYGON_CLOSE_TOLERANCE, self.current_polygon_points[0][1]-POLYGON_CLOSE_TOLERANCE))
            pygame.display.flip()
            self.clock.tick(60)

    def is_point_in_component(self, point, component):
        st = component['shape_type']; sd = component.get('shape_data', []);
        if not sd: return False
        if st == 'rectangle': return pygame.Rect(sd).collidepoint(point)
        if st == 'circle': return math.hypot(point[0]-sd[0], point[1]-sd[1]) <= sd[2]
        if st == 'polygon': # Ray casting algorithm
            x, y = point; n = len(sd); inside = False
            p1x, p1y = sd[0]
            for i in range(n + 1):
                p2x, p2y = sd[i % n]
                if y > min(p1y, p2y):
                    if y <= max(p1y, p2y):
                        if x <= max(p1x, p2x):
                            if p1y != p2y: xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                            if p1x == p2x or x <= xinters: inside = not inside
                p1x, p1y = p2x, p2y
            return inside
        return False

if __name__ == '__main__':
    tool = LayoutTool()
    tool.run()