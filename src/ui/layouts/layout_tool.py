import pygame
import json
import sys
import math
import os
import re # Import the regular expression library for sanitizing
from tkinter import filedialog, Tk

# --- Configuration ---
SUPPORTED_MODES = [{"name": "Windowed", "size": (1280, 720), "flags": 0}]
POLYGON_CLOSE_TOLERANCE = 15
FONT_SIZE = 22
RESIZE_HANDLE_SIZE = 10

# --- Colors ---
COLOR_WHITE=(255,255,255); COLOR_BLACK=(0,0,0); COLOR_RECT_FILL=(255,165,0,150)
COLOR_RECT_BORDER=(255,255,0); COLOR_SELECTED_BORDER=(255,0,255,255)
COLOR_POLYGON_VERTEX=(0,255,0); COLOR_POLYGON_LINE=(0,200,0)
COLOR_SNAP_CIRCLE=(0,255,255,100); COLOR_RESIZE_HANDLE=(0,255,255,200)

class LayoutTool:
    def __init__(self):
        pygame.init()
        self.tk_root = Tk(); self.tk_root.withdraw()
        try:
            info = pygame.display.Info()
            NATIVE_SIZE = (info.current_w, info.current_h)
            SUPPORTED_MODES.append({"name": "Fullscreen", "size": NATIVE_SIZE, "flags": pygame.FULLSCREEN | pygame.SCALED})
        except pygame.error: print("Could not get native display info, fallback to 1920x1080 for fullscreen.")
        self.current_mode_index = 0
        self.set_display_mode()
        pygame.display.set_caption("Linie 1 - UI Layout Code Generator")
        self.font = pygame.font.Font(None, FONT_SIZE)
        self.clock = pygame.time.Clock()
        self.background = pygame.Surface((self.screen_width, self.screen_height)); self.background.fill(COLOR_BLACK)
        self.tool_directory = os.path.dirname(os.path.abspath(__file__))
        self.regions = {}; self.selected_name = None
        self.mode = "select"; self.start_pos = None; self.current_polygon_points = []; self.history = []
        self.is_moving = False; self.is_resizing = False; self.move_offset = (0,0); self.resize_handle_index = -1

    # --- NEW: Function to sanitize names for Python variables ---
    def sanitize_name(self, name):
        # Replace spaces and hyphens with underscores
        name = name.replace(' ', '_').replace('-', '_')
        # Remove any characters that are not letters, numbers, or underscores
        name = re.sub(r'\W|^(?=\d)', '', name)
        return name.lower()

    def prompt_and_export(self):
        current_mode = SUPPORTED_MODES[self.current_mode_index]
        suggested_name = f"my_layout_{current_mode['size'][0]}x{current_mode['size'][1]}"
        filename = self.handle_simple_input(f"Enter filename for {current_mode['name']} layout:", suggested_name)
        if not filename: print("Export cancelled."); return
        
        # Sanitize the filename itself
        safe_filename = self.sanitize_name(filename)
        full_path = os.path.join(self.tool_directory, f"{safe_filename}.py")

        with open(full_path, 'w') as f:
            f.write("# THIS FILE IS AUTO-GENERATED BY THE LAYOUT TOOL. DO NOT EDIT MANUALLY.\nimport pygame\n\n")
            sorted_regions = sorted(self.regions.items(), key=lambda item: item[0])
            for name, region in sorted_regions:
                st=region['shape_type']; sd=region['shape_data']; bounds_rect=pygame.Rect(0,0,0,0)
                if st in ['rectangle', 'board']: bounds_rect = pygame.Rect(sd)
                elif st == 'circle': bounds_rect = pygame.Rect(sd[0]-sd[2], sd[1]-sd[2], sd[2]*2, sd[2]*2)
                elif st == 'polygon' and sd: min_x=min(p[0] for p in sd); max_x=max(p[0] for p in sd); min_y=min(p[1] for p in sd); max_y=max(p[1] for p in sd); bounds_rect=pygame.Rect(min_x,min_y,max_x-min_x,max_y-min_y)
                f.write(f"{name}_bounds = pygame.Rect({bounds_rect.x},{bounds_rect.y},{bounds_rect.width},{bounds_rect.height})\n")
                data_str = f"'shape': '{st}'"
                if st == 'circle': data_str += f", 'center': ({sd[0]},{sd[1]}), 'radius': {sd[2]}"
                if st == 'polygon': data_str += f", 'points': {sd}"
                if st == 'board': data_str += f", 'rows': {region.get('rows', 1)}, 'cols': {region.get('cols', 1)}"
                f.write(f"{name}_data = {{{data_str}}}\n\n")
        print(f"--- Layout code successfully generated in '{full_path}' ---")

    def finalize_and_add_shape(self, shape_type, shape_data):
        name_input = self.handle_simple_input(f"Enter unique name for new {shape_type}:")
        if not name_input: print("Cancelled."); return
        
        # Sanitize the name here before using it
        safe_name = self.sanitize_name(name_input)
        if not safe_name: print("Cancelled: Name is invalid after sanitizing."); return

        if shape_type == "polygon": shape_data = list(shape_data)
        self.add_region(safe_name, {"shape_type": shape_type, "shape_data": shape_data, "hierarchy": 10})

    # --- All other methods remain the same, but are included for completeness ---
    def set_display_mode(self):
        mode = SUPPORTED_MODES[self.current_mode_index]
        self.screen = pygame.display.set_mode(mode["size"], mode["flags"])
        self.screen_width, self.screen_height = self.screen.get_size()
        self.screen_rect = self.screen.get_rect()
        print(f"Switched to {mode['name']} mode ({self.screen_width}x{self.screen_height})")
    def toggle_resolution(self):
        old_mode=SUPPORTED_MODES[self.current_mode_index]; self.current_mode_index=(self.current_mode_index+1)%len(SUPPORTED_MODES); new_mode=SUPPORTED_MODES[self.current_mode_index]
        self.set_display_mode(); self.background=pygame.transform.scale(self.background,(self.screen_width,self.screen_height))
        scale_x=new_mode["size"][0]/old_mode["size"][0]; scale_y=new_mode["size"][1]/old_mode["size"][1]
        for name, region in self.regions.items():
            st=region['shape_type']; sd=region['shape_data']
            if st=='rectangle' or st=='board': region['shape_data']=[int(sd[0]*scale_x), int(sd[1]*scale_y), int(sd[2]*scale_x), int(sd[3]*scale_y)]
            elif st=='circle': region['shape_data']=[int(sd[0]*scale_x), int(sd[1]*scale_y), int(sd[2]*((scale_x+scale_y)/2))]
            elif st=='polygon': region['shape_data']=[(int(p[0]*scale_x), int(p[1]*scale_y)) for p in sd]
    def load_mockup(self):
        filepath = filedialog.askopenfilename(title="Select Mockup Image")
        if filepath:
            try: self.background = pygame.transform.scale(pygame.image.load(filepath).convert(), (self.screen_width, self.screen_height))
            except Exception as e: print(f"Error loading image: {e}")
    def add_region(self, name, region_data):
        if name in self.regions: print(f"Warning: Region '{name}' exists. Overwriting.")
        self.regions[name] = region_data; self.history.append(name); print(f"Added/Updated: '{name}'")
    def undo_last_action(self):
        if not self.history: return
        last_name = self.history.pop()
        if last_name in self.regions: del self.regions[last_name]; print(f"Undone: '{last_name}'")
    def handle_simple_input(self, prompt, default_text=""):
        input_text=default_text; backspace_timer=0; backspace_initial_delay=500; backspace_repeat_delay=50
        while True:
            dt=self.clock.tick(60)
            for event in pygame.event.get():
                if event.type==pygame.KEYDOWN:
                    if event.key==pygame.K_RETURN: return input_text
                    elif event.key==pygame.K_BACKSPACE: input_text=input_text[:-1]; backspace_timer=-backspace_initial_delay
                    else: input_text+=event.unicode
            keys=pygame.key.get_pressed()
            if keys[pygame.K_BACKSPACE]:
                backspace_timer+=dt
                if backspace_timer>backspace_repeat_delay: input_text=input_text[:-1]; backspace_timer=0
            self.draw()
            box_rect=pygame.Rect(self.screen_width//2-300,self.screen_height//2-50,600,100)
            pygame.draw.rect(self.screen,(30,30,70),box_rect); pygame.draw.rect(self.screen,COLOR_WHITE,box_rect,2)
            self.screen.blit(self.font.render(prompt,True,COLOR_WHITE),(box_rect.x+10,box_rect.y+10))
            self.screen.blit(self.font.render(input_text,True,COLOR_WHITE),(box_rect.x+10,box_rect.y+40))
            pygame.display.flip()
    def get_resize_handles(self, rect):
        return [pygame.Rect(rect.left-RESIZE_HANDLE_SIZE//2,rect.top-RESIZE_HANDLE_SIZE//2,RESIZE_HANDLE_SIZE,RESIZE_HANDLE_SIZE), pygame.Rect(rect.right-RESIZE_HANDLE_SIZE//2,rect.top-RESIZE_HANDLE_SIZE//2,RESIZE_HANDLE_SIZE,RESIZE_HANDLE_SIZE), pygame.Rect(rect.left-RESIZE_HANDLE_SIZE//2,rect.bottom-RESIZE_HANDLE_SIZE//2,RESIZE_HANDLE_SIZE,RESIZE_HANDLE_SIZE), pygame.Rect(rect.right-RESIZE_HANDLE_SIZE//2,rect.bottom-RESIZE_HANDLE_SIZE//2,RESIZE_HANDLE_SIZE,RESIZE_HANDLE_SIZE)]
    def draw_region(self, name, region):
        st=region['shape_type']; sd=region.get('shape_data',[]); info_text=f"{name} H:{region.get('hierarchy',1)}"
        border_color=COLOR_SELECTED_BORDER if name==self.selected_name else COLOR_RECT_BORDER
        try:
            if not sd: return
            if st in ["rectangle", "board"]:
                rect=pygame.Rect(sd); s=pygame.Surface(rect.size,pygame.SRCALPHA); s.fill(COLOR_RECT_FILL); self.screen.blit(s,rect.topleft); pygame.draw.rect(self.screen,border_color,rect,2)
                if st=="board":
                    rows,cols=region.get('rows',1),region.get('cols',1)
                    if rows > 1:
                        for r in range(1,rows): pygame.draw.line(self.screen,COLOR_BLACK,(rect.x,rect.y+r*rect.h/rows),(rect.right,rect.y+r*rect.h/rows))
                    if cols > 1:
                        for c in range(1,cols): pygame.draw.line(self.screen,COLOR_BLACK,(rect.x+c*rect.w/cols,rect.y),(rect.x+c*rect.w/cols,rect.bottom))
                if name==self.selected_name and st == "board":
                    for handle in self.get_resize_handles(rect): pygame.draw.rect(self.screen,COLOR_RESIZE_HANDLE,handle)
                self.screen.blit(self.font.render(info_text,True,COLOR_BLACK,COLOR_WHITE),(rect.x+5,rect.y+5))
            elif st=="circle":
                center,r=(sd[0],sd[1]),sd[2]; s=pygame.Surface((r*2,r*2),pygame.SRCALPHA); pygame.draw.circle(s,COLOR_RECT_FILL,(r,r),r); self.screen.blit(s,(center[0]-r,center[1]-r)); pygame.draw.circle(self.screen,border_color,center,r,2); self.screen.blit(self.font.render(info_text,True,COLOR_BLACK,COLOR_WHITE),(center[0]-r+5,center[1]-r+5))
            elif st=="polygon":
                pygame.draw.polygon(self.screen,COLOR_RECT_FILL,sd); pygame.draw.polygon(self.screen,border_color,sd,2); self.screen.blit(self.font.render(info_text,True,COLOR_BLACK,COLOR_WHITE),(sd[0][0]+5,sd[0][1]+5))
        except (ValueError,IndexError) as e: print(f"Error drawing '{name}': {e}")
    def draw(self):
        self.screen.blit(self.background,(0,0))
        sorted_regions = sorted(self.regions.items(), key=lambda item:item[1].get('hierarchy',1))
        for name, region in sorted_regions: self.draw_region(name, region)
        mode_text = SUPPORTED_MODES[self.current_mode_index]['name']
        help_text=[f"MODE: {self.mode.upper()} | RES: {mode_text} | SELECTED: {self.selected_name}","[V] Toggle Res | [B]oard | [R]ect | [C]ircle | [G]eometry", "Right-click selected to set Hierarchy | [M]ockup | [E]xport | [Ctrl+Z] Undo"]
        if self.mode=='draw_polygon': help_text.append("Left-click adds point | Click near start OR Right-click to finish")
        for i,line in enumerate(help_text):
            surf=self.font.render(line,True,COLOR_WHITE); bg_rect=surf.get_rect(topleft=(10,10+i*(FONT_SIZE+4))).inflate(8,8); s=pygame.Surface(bg_rect.size,pygame.SRCALPHA); s.fill((0,0,0,180)); self.screen.blit(s,bg_rect.topleft); self.screen.blit(surf,(14,14+i*(FONT_SIZE+4)))
    def run(self):
        while True:
            mouse_pos=pygame.mouse.get_pos(); clamped_mouse_pos=(max(0,min(self.screen_width-1,mouse_pos[0])),max(0,min(self.screen_height-1,mouse_pos[1])))
            dt = self.clock.tick(60)
            for event in pygame.event.get():
                if event.type==pygame.QUIT or (event.type==pygame.KEYDOWN and event.key==pygame.K_F4 and (pygame.key.get_mods()&pygame.KMOD_ALT)): pygame.quit(); sys.exit()
                if event.type==pygame.KEYDOWN:
                    if event.key==pygame.K_ESCAPE: self.mode="select"; self.current_polygon_points.clear(); self.selected_name=None
                    elif event.key==pygame.K_v: self.toggle_resolution()
                    elif event.key==pygame.K_b: self.handle_board_creation()
                    elif event.key==pygame.K_r: self.mode="draw_rectangle"
                    elif event.key==pygame.K_c: self.mode="draw_circle"
                    elif event.key==pygame.K_g: self.mode="draw_polygon"; self.current_polygon_points.clear()
                    elif event.key==pygame.K_m: self.load_mockup()
                    elif event.key==pygame.K_e: self.prompt_and_export()
                    elif event.key==pygame.K_z and (pygame.key.get_mods()&pygame.KMOD_CTRL): self.undo_last_action()
                if event.type==pygame.MOUSEBUTTONDOWN:
                    if self.mode == "select":
                        if event.button == 1:
                            is_resizing_handle_clicked = False
                            if self.selected_name and self.regions.get(self.selected_name,{}).get('shape_type')=='board':
                                for i, handle in enumerate(self.get_resize_handles(pygame.Rect(self.regions[self.selected_name]['shape_data']))):
                                    if handle.collidepoint(clamped_mouse_pos): self.is_resizing=True; self.resize_handle_index=i; is_resizing_handle_clicked=True; break
                            if not is_resizing_handle_clicked:
                                clicked_name=self.get_component_at_pos(clamped_mouse_pos); self.selected_name=clicked_name
                                if self.selected_name:
                                    self.is_moving=True
                                    topleft=self._get_region_topleft(self.regions[self.selected_name]); self.move_offset=(clamped_mouse_pos[0]-topleft[0],clamped_mouse_pos[1]-topleft[1])
                        elif event.button == 3 and self.selected_name:
                            new_h=self.handle_simple_input(f"Set hierarchy for '{self.selected_name}' (higher is on top):")
                            try: self.regions[self.selected_name]['hierarchy']=int(new_h)
                            except(ValueError,KeyError): print("Invalid hierarchy.")
                    elif self.mode in ["draw_rectangle","draw_circle"]: self.start_pos=clamped_mouse_pos
                    elif self.mode == "draw_polygon":
                        close_shape=len(self.current_polygon_points)>=3 and math.hypot(clamped_mouse_pos[0]-self.current_polygon_points[0][0],clamped_mouse_pos[1]-self.current_polygon_points[0][1])<POLYGON_CLOSE_TOLERANCE
                        if close_shape or (event.button==3 and len(self.current_polygon_points)>=3): self.finalize_and_add_shape("polygon",self.current_polygon_points); self.current_polygon_points.clear(); self.mode="select"
                        elif event.button == 1: self.current_polygon_points.append(clamped_mouse_pos)
                if event.type==pygame.MOUSEBUTTONUP and event.button==1:
                    self.is_moving=False; self.is_resizing=False
                    if self.start_pos:
                        if self.mode=="draw_rectangle":
                            rect=pygame.Rect(min(self.start_pos[0],clamped_mouse_pos[0]),min(self.start_pos[1],clamped_mouse_pos[1]),abs(self.start_pos[0]-clamped_mouse_pos[0]),abs(self.start_pos[1]-clamped_mouse_pos[1])); rect.clamp_ip(self.screen_rect)
                            if rect.width>5 and rect.height>5: self.finalize_and_add_shape("rectangle",[rect.x,rect.y,rect.width,rect.height])
                        elif self.mode=="draw_circle":
                            cx,cy=self.start_pos; r=int(math.hypot(clamped_mouse_pos[0]-cx,clamped_mouse_pos[1]-cy)); max_r=min(cx,self.screen_width-cx,cy,self.screen_height-cy); final_r=min(r,max_r)
                            if final_r>5: self.finalize_and_add_shape("circle",[cx,cy,final_r])
                        self.start_pos=None; self.mode="select"
            if self.is_moving and self.selected_name:
                region=self.regions.get(self.selected_name)
                if region:
                    new_topleft_x=clamped_mouse_pos[0]-self.move_offset[0]; new_topleft_y=clamped_mouse_pos[1]-self.move_offset[1]
                    old_topleft_x,old_topleft_y=self._get_region_topleft(region); dx=new_topleft_x-old_topleft_x; dy=new_topleft_y-old_topleft_y
                    sd=region['shape_data']
                    if region['shape_type'] in ['rectangle','board','circle']: sd[0]+=dx; sd[1]+=dy
                    elif region['shape_type']=='polygon': region['shape_data']=[(p[0]+dx,p[1]+dy) for p in sd]
            elif self.is_resizing and self.selected_name:
                region=self.regions[self.selected_name]; rect=pygame.Rect(region['shape_data']); rows,cols=region.get('rows',1),region.get('cols',1); aspect_ratio = cols/rows if rows>0 else 1; anchor=(0,0)
                if self.resize_handle_index==0: anchor=rect.bottomright
                elif self.resize_handle_index==1: anchor=rect.bottomleft
                elif self.resize_handle_index==2: anchor=rect.topright
                elif self.resize_handle_index==3: anchor=rect.topleft
                new_width=abs(clamped_mouse_pos[0]-anchor[0]); new_height=abs(clamped_mouse_pos[1]-anchor[1])
                if new_width/aspect_ratio > new_height: final_width=new_height*aspect_ratio; final_height=new_height
                else: final_width=new_width; final_height=new_width/aspect_ratio
                if self.resize_handle_index==0: rect.topleft=(anchor[0]-final_width,anchor[1]-final_height)
                elif self.resize_handle_index==1: rect.topright=(anchor[0]+final_width,anchor[1]-final_height)
                elif self.resize_handle_index==2: rect.bottomleft=(anchor[0]-final_width,anchor[1]+final_height)
                elif self.resize_handle_index==3: rect.bottomright=(anchor[0]+final_width,anchor[1]+final_height)
                rect.width,rect.height=final_width,final_height
                region['shape_data']=[rect.x,rect.y,rect.width,rect.height]
            self.draw()
            if self.start_pos:
                if self.mode=="draw_rectangle":pygame.draw.rect(self.screen,COLOR_RECT_BORDER,(min(self.start_pos[0],clamped_mouse_pos[0]),min(self.start_pos[1],clamped_mouse_pos[1]),abs(self.start_pos[0]-clamped_mouse_pos[0]),abs(self.start_pos[1]-clamped_mouse_pos[1])),2)
                elif self.mode=="draw_circle":pygame.draw.circle(self.screen,COLOR_RECT_BORDER,self.start_pos,int(math.hypot(clamped_mouse_pos[0]-self.start_pos[0],clamped_mouse_pos[1]-self.start_pos[1])),2)
            if self.mode=="draw_polygon" and self.current_polygon_points:
                pygame.draw.lines(self.screen,COLOR_POLYGON_LINE,False,self.current_polygon_points+[clamped_mouse_pos],2)
                for p in self.current_polygon_points: pygame.draw.circle(self.screen,COLOR_POLYGON_VERTEX,p,4)
                if len(self.current_polygon_points)>=2 and math.hypot(clamped_mouse_pos[0]-self.current_polygon_points[0][0],clamped_mouse_pos[1]-self.current_polygon_points[0][1])<POLYGON_CLOSE_TOLERANCE:
                    s=pygame.Surface((POLYGON_CLOSE_TOLERANCE*2,POLYGON_CLOSE_TOLERANCE*2),pygame.SRCALPHA);pygame.draw.circle(s,COLOR_SNAP_CIRCLE,(POLYGON_CLOSE_TOLERANCE,POLYGON_CLOSE_TOLERANCE),POLYGON_CLOSE_TOLERANCE);self.screen.blit(s,(self.current_polygon_points[0][0]-POLYGON_CLOSE_TOLERANCE,self.current_polygon_points[0][1]-POLYGON_CLOSE_TOLERANCE))
            pygame.display.flip()
            
    def _get_region_topleft(self, region):
        st=region['shape_type']; sd=region['shape_data']
        if st in ['rectangle','board']: return (sd[0],sd[1])
        if st=='circle': return (sd[0]-sd[2],sd[1]-sd[2])
        if st=='polygon' and sd: return (min(p[0] for p in sd),min(p[1] for p in sd))
        return (0,0)
    def add_region(self, name, region_data):
        if name in self.regions: print(f"Warning: Region '{name}' exists. Overwriting.")
        self.regions[name] = region_data; self.history.append(name); print(f"Added/Updated: '{name}'")
    def undo_last_action(self):
        if not self.history: return
        last_name = self.history.pop()
        if last_name in self.regions: del self.regions[last_name]; print(f"Undone: '{last_name}'")
    def handle_simple_input(self, prompt, default_text=""):
        input_text=default_text; backspace_timer=0; backspace_initial_delay=500; backspace_repeat_delay=50
        while True:
            dt=self.clock.tick(60)
            for event in pygame.event.get():
                if event.type==pygame.KEYDOWN:
                    if event.key==pygame.K_RETURN: return input_text
                    elif event.key==pygame.K_BACKSPACE: input_text=input_text[:-1]; backspace_timer=-backspace_initial_delay
                    else: input_text+=event.unicode
            keys=pygame.key.get_pressed()
            if keys[pygame.K_BACKSPACE]:
                backspace_timer+=dt
                if backspace_timer>backspace_repeat_delay: input_text=input_text[:-1]; backspace_timer=0
            self.draw()
            box_rect=pygame.Rect(self.screen_width//2-300,self.screen_height//2-50,600,100)
            pygame.draw.rect(self.screen,(30,30,70),box_rect); pygame.draw.rect(self.screen,COLOR_WHITE,box_rect,2)
            self.screen.blit(self.font.render(prompt,True,COLOR_WHITE),(box_rect.x+10,box_rect.y+10))
            self.screen.blit(self.font.render(input_text,True,COLOR_WHITE),(box_rect.x+10,box_rect.y+40))
            pygame.display.flip()
    def finalize_and_add_shape(self, shape_type, shape_data):
        name_input = self.handle_simple_input(f"Enter unique name for new {shape_type}:")
        if not name_input: print("Cancelled."); return
        safe_name = self.sanitize_name(name_input)
        if not safe_name: print("Cancelled: Invalid name."); return
        if shape_type == "polygon": shape_data = list(shape_data)
        self.add_region(safe_name, {"shape_type": shape_type, "shape_data": shape_data, "hierarchy": 10})
    def get_component_at_pos(self, pos):
        colliding = [(comp.get('hierarchy', 1), name) for name, comp in self.regions.items() if self.is_point_in_component(pos, comp)]
        if not colliding: return None
        colliding.sort(key=lambda x: x[0], reverse=True)
        return colliding[0][1]
    def is_point_in_component(self, point, component):
        st=component['shape_type']; sd=component.get('shape_data',[]);
        if not sd: return False
        if st in ['rectangle','board']: return pygame.Rect(sd).collidepoint(point)
        if st=='circle': return math.hypot(point[0]-sd[0], point[1]-sd[1]) <= sd[2]
        if st=='polygon':
            x,y=point; n=len(sd); inside=False; p1x,p1y=sd[0]
            for i in range(n+1):
                p2x,p2y=sd[i%n]
                if y>min(p1y,p2y) and y<=max(p1y,p2y) and x<=max(p1x,p2x):
                    if p1y!=p2y: xinters=(y-p1y)*(p2x-p1x)/(p2y-p1y)+p1x
                    if p1x==p2x or x<=xinters: inside=not inside
                p1x,p1y=p2x,p2y
            return inside
        return False
    def sanitize_name(self, name):
        name = name.replace(' ', '_').replace('-', '_')
        name = re.sub(r'\W|^(?=\d)', '', name)
        return name.lower()


if __name__ == '__main__':
    expected_path = os.path.join('src', 'ui', 'layouts')
    if os.path.basename(os.getcwd()) != 'layouts' and os.path.exists(expected_path):
        os.chdir(expected_path)
    tool = LayoutTool()
    tool.run()